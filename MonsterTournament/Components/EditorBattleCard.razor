@using System.Text.RegularExpressions
@using MonsterTournament.Client.Models
@using System.IO.Compression
@using System.Text.Json
@inject IJSRuntime JS

<div class="d-flex justify-start align-center gap-1">
    <MudFileUpload T="IBrowserFile" FilesChanged="LoadCard" Accept=@BattleCardLoader.FileExtension Class="mr-5">
        <ActivatorContent>
            <MudButton StartIcon="@Icons.Material.Filled.FileOpen" Variant="Variant.Filled"
                       Color="Color.Primary">開く</MudButton>
        </ActivatorContent>
    </MudFileUpload>
    <MudButton StartIcon="@Icons.Material.Filled.Download" Variant="Variant.Filled" Color="Color.Primary"
               Disabled="@(!success)" @onclick=Download>ダウンロード</MudButton>
</div>
<MudForm @ref="form" @bind-IsValid="@success" @bind-Errors="@errors">
    <MudTextField T="string" Class="mb-5" Label="名前" Required="true" @bind-Text=battleCard.Name RequiredError="name is required!" />
    <MudNumericField Class="mb-5" Label="HP" Variant="Variant.Text" Min="0" @bind-Value=battleCard.Hp />

    <MudFileUpload T="IBrowserFile" @ref=mudFileUpload FilesChanged="UploadImage" Accept=".png, .jpg">
        <ActivatorContent>
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       StartIcon="@Icons.Material.Filled.CloudUpload">
                画像
            </MudButton>
        </ActivatorContent>
    </MudFileUpload>

    <MudContainer Class="d-flex justify-center mb-5">
        @if (imageBytes.Length > 0)
        {
            <MudImage id=@cardImageElementId Height=@Config.ImageSize.Y Width=@Config.ImageSize.X
                      ObjectPosition="ObjectPosition.Center" />
        }
        else
        {
            <MudPaper Outlined="true" Square="true"
                      Height=@($"{@Config.ImageSize.Y}px") Width=@($"{@Config.ImageSize.X}px")
                      Class="d-flex justify-center align-center">
                <MudText>画像(@(Config.ImageSize.X)x@(Config.ImageSize.Y))</MudText>
            </MudPaper>
        }
    </MudContainer>

    @foreach (var i in Enumerable.Range(0, battleCard.Attacks.Length))
    {
        <MudPaper Class="ma-1 pa-2">
            <MudText>@("攻撃" + (@i + 1))</MudText>
            <MudContainer>
                <MudGrid Justify="Justify.Center">
                    <MudItem xs="12" lg="5">
                        <MudTextField T="string" Label="名前" Required="true"
                                      @bind-Value=battleCard.Attacks[i].Name />
                    </MudItem>

                    <MudItem xs="12" lg="2">
                        <MudSelect T="BattleCardAttackType" Label="種類" AnchorOrigin="Origin.BottomCenter" FullWidth="false"
                                   @bind-Value=battleCard.Attacks[i].Type>
                            @foreach (var t in Enum.GetValues<BattleCardAttackType>())
                            {
                                <MudSelectItem Value="@t">@t.ToDisplayString()</MudSelectItem>
                            }
                        </MudSelect>
                    </MudItem>

                    <MudItem xs="12" lg="5">
                        @switch (battleCard.Attacks[i].Type)
                        {
                            case BattleCardAttackType.Attack:
                            case BattleCardAttackType.Bouhatu:
                            case BattleCardAttackType.ReAttack:
                                <MudNumericField Label="威力" Variant="Variant.Text" Min="0"
                                                 @bind-Value=battleCard.Attacks[i].IntValue />
                                break;
                            case BattleCardAttackType.Heal:
                                <MudNumericField Label="回復量" Variant="Variant.Text" Min="0"
                                                 @bind-Value=battleCard.Attacks[i].IntValue />
                                break;
                            case BattleCardAttackType.Buff:
                                <MudNumericField Label="上昇量" Variant="Variant.Text"
                                                 @bind-Value=battleCard.Attacks[i].IntValue />
                                break;
                            case BattleCardAttackType.Transform:
                                <MudTextField T="string" Label="変身先" Required="true"
                                              @bind-Value=battleCard.Attacks[i].Value />
                                break;
                            case BattleCardAttackType.BattleState:
                                <MudTextField T="string" Label="状態異常" Required="true"
                                              @bind-Value=battleCard.Attacks[i].Value />
                                break;
                            case BattleCardAttackType.Special:
                                <MudTextField T="string" Label="必殺技" Required="true"
                                              @bind-Value=battleCard.Attacks[i].Value />
                                break;
                            case BattleCardAttackType.Other:
                                <MudTextField T="string" Label="効果" Required="true"
                                              @bind-Value=battleCard.Attacks[i].Value />
                                break;
                            default:
                                @(battleCard.Attacks[i].Value = "")
                                break;
                        }
                    </MudItem>
                </MudGrid>
            </MudContainer>
        </MudPaper>
    }
</MudForm>

<FileUpload @ref=fileUpload />
<FileDownload @ref=fileDownload />

@code {
#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    MudForm form;
    MudFileUpload<IBrowserFile> mudFileUpload;
    FileUpload fileUpload;
    FileDownload fileDownload;
#pragma warning restore CS8618

    bool success;
    string[] errors = { };

    private readonly string cardImageElementId = Guid.NewGuid().ToString();

    private BattleCard battleCard = new BattleCard()
        {
            Name = "",
            Hp = 0,
            Attacks = Enumerable.Range(1, 6).Select(i => new BattleCardAttack()).ToArray()
        };
    private byte[] imageBytes = [];

    private async Task UploadImage(IBrowserFile? file)
    {
        Console.WriteLine("upload image");

        if (file == null)
        {
            Console.WriteLine("キャンセル");
            return;
        }

        battleCard.ImageFileName = file.Name;

        var buffer = new byte[file.Size];
        using var fileStream = file.OpenReadStream();
        await fileStream.ReadAsync(buffer);
        imageBytes = buffer;

        StateHasChanged();

        await fileUpload.SetImage(cardImageElementId, new MemoryStream(imageBytes));
    }

    private async Task LoadCard(IBrowserFile file)
    {
        if (file == null)
        {
            Console.WriteLine("キャンセル");
            return;
        }

        var buffer = new byte[file.Size];
        using var fileStream = file.OpenReadStream();
        await fileStream.ReadAsync(buffer);

        var (cardOrNull, iBytes) = await new BattleCardLoader().Load(buffer);

        if (cardOrNull == null)
        {
            //TODO : カードの読み込みに失敗 error handling
            Console.WriteLine("カードの読み込みに失敗");
            return;
        }

        battleCard = cardOrNull;
        imageBytes = iBytes;
        await this.mudFileUpload.ClearAsync();

        StateHasChanged();
        await fileUpload.SetImage(cardImageElementId, new MemoryStream(iBytes));

        StateHasChanged();
        await form.Validate();
    }

    private async Task Download()
    {
        var file = await new BattleCardLoader().Save(battleCard, imageBytes);
        await fileDownload.DownloadFileFromStream(file.fileName, new MemoryStream(file.Bytes));
    }
}
