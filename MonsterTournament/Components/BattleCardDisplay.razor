@using System.IO.Compression
@using System.Text
@using System.Text.Json
@using MonsterTournament.Models
@inject IJSRuntime JS
@inject IDialogService DialogService

<MudPaper Outlined="true" Class="mb-5">
    <MudContainer Class="d-flex justify-center align-center gap-4 ma-2">
        <MudButton Disabled=!this.cardLoaded Variant="Variant.Filled" Color="Color.Info" Size="Size.Large"
                   @onclick="Attack">攻撃</MudButton>

        <MudButtonGroup Color="Color.Primary" Variant="Variant.Outlined" OverrideStyles="false">
            @if (this.monster.BattleStateAttached)
            {
                <MudButton Disabled=!this.cardLoaded Variant="Variant.Outlined" Size="Size.Small" Color="Color.Warning"
                           @onclick="this.monster.DettacheBattleState">
                    <AttackIcon AttackType="BattleCardAttackType.BattleState" />解除
                </MudButton>
            }
            else
            {
                <MudButton Disabled=!this.cardLoaded Variant="Variant.Outlined" Size="Size.Small" Color="Color.Warning"
                           @onclick="ShowStateDialog">
                    <AttackIcon AttackType="BattleCardAttackType.BattleState" />
                </MudButton>
            }

            <MudButton Disabled=!this.cardLoaded Variant="Variant.Outlined" Size="Size.Small" Color="Color.Secondary"
                       @onclick="ShowTransformDialog">
                <AttackIcon AttackType="BattleCardAttackType.Transform" />
            </MudButton>

            @if (this.monster.SpecialAttackAttached)
            {
                <MudButton Disabled=!this.cardLoaded Variant="Variant.Outlined" Size="Size.Small" Color="Color.Secondary"
                           @onclick="this.monster.DettacheSpecial">
                    <AttackIcon AttackType="BattleCardAttackType.Special" />解除
                </MudButton>
            }
            else
            {
                <MudButton Disabled=!this.cardLoaded Variant="Variant.Outlined" Size="Size.Small" Color="Color.Secondary"
                           @onclick="ShowSpecialDialog">
                    <AttackIcon AttackType="BattleCardAttackType.Special" />
                </MudButton>
            }
        </MudButtonGroup>

        <div class="d-flex justify-center align-center gap-1">
            バフ:
            <MudIconButton Disabled=!this.cardLoaded Icon="@Icons.Material.Filled.KeyboardDoubleArrowUp" Variant="Variant.Filled"
                           Color="Color.Success" Size="Size.Small" @onclick="this.Buff" />
            <MudIconButton Disabled=!this.cardLoaded Icon="@Icons.Material.Filled.KeyboardDoubleArrowDown" Variant="Variant.Filled"
                           Color="Color.Secondary" Size="Size.Small" @onclick="this.Debuff" />
        </div>
    </MudContainer>
</MudPaper>

<MudPaper Outlined="true">
    <MudContainer>
        <div class="d-flex align-center justify-start">
            <MudText Class="overflow-hidden" Typo="Typo.h5">@monster.Def.Name</MudText>
        </div>
        <div class="d-flex align-center justify-start gap-1">
            <MudText Typo="Typo.body1" Class="mr-5">HP: </MudText>
            <MudProgressLinear Class="mr-5" Value="@monster.CurrentHp" Min="0" Max="@monster.Def.Hp" Color="Color.Success" Size="Size.Large">
                <MudText Typo="Typo.h5" Color="Color.Dark" Style="-webkit-text-stroke: 1px #FFF;">
                    <b>@monster.CurrentHp / @monster.Def.Hp</b>
                </MudText>
            </MudProgressLinear>
            <MudIconButton Icon="@Icons.Material.Filled.Add" Variant="Variant.Filled" Color="Color.Success" Size="Size.Small"
                           @onclick="AddHp" />
            <MudIconButton Icon="@Icons.Material.Filled.Remove" Variant="Variant.Filled" Color="Color.Error" Size="Size.Small"
                           @onclick="SubHp" />
        </div>

        <MudContainer Class="d-flex justify-center mb-3">
            <MudImage id=@cardImageElementId Class="@(monster.IsAlive ? "" : "monochrome")" Height="250" Width="250" ObjectPosition="ObjectPosition.Center" />
        </MudContainer>

        <MudContainer Class="d-flex justify-center gap-4 mb-3">
            <MudText Typo="Typo.body1">状態: @this.monster.BattleStateName</MudText>
            <MudText Typo="Typo.body1">バフ: @this.monster.DiffValue</MudText>
        </MudContainer>


        <MudTabs PanelClass="pt-2">
            <MudTabPanel Text="@actionName">
                @foreach (var attack in this.monster.Attacks)
                {
                    <MudPaper Outlined="true" Class="@($"{(attack.IsSelected ? "mud-primary" : "")} pa-2 mb-2")">
                        <MudGrid Justify="Justify.FlexStart" Class="align-center">
                            <MudItem sm="1">
                                <AttackIcon AttackType="@attack.Type" />
                            </MudItem>

                            @if (this.monster.SpecialAttackAttached)
                            {
                                <MudItem sm="4">
                                    <MudText Class="overflow-hidden"
                                             Style=@($"height: 1.6rem;font-size: clamp(10px, {10f / Math.Max(1, attack.SpecialName.Length)}rem, 20px)")
                                             Align="Align.Center" Typo="Typo.body1">@attack.SpecialName</MudText>
                                </MudItem>
                                <MudItem sm="7">
                                    <MudText Class="overflow-hidden"
                                             Style=@($"height: 1.6rem;font-size: clamp(10px, {8f / Math.Max(1, attack.SpecialAttackDescription.Length)}rem, 15px)")
                                             Align="Align.Center">@attack.SpecialAttackDescription</MudText>
                                </MudItem>
                            }
                            else
                            {
                                @if (attack.Def.Type == BattleCardAttackType.Transform
                               || attack.Def.Type == BattleCardAttackType.Special)
                                {
                                    <MudItem sm="8">
                                        <MudText Class="overflow-hidden"
                                                 Style=@($"height: 1.6rem;font-size: clamp(10px, {15f / Math.Max(1, attack.Description.Length)}rem, 20px)")
                                                 Align="Align.Center" Typo="Typo.body1">@attack.Description</MudText>
                                    </MudItem>
                                }
                                else
                                {
                                    <MudItem sm="4">
                                        <MudText Class="overflow-hidden"
                                                 Style=@($"height: 1.6rem;font-size: clamp(10px, {10f / Math.Max(1, attack.Name.Length)}rem, 20px)")>@attack.Name</MudText>
                                    </MudItem>
                                    <MudItem sm="4">
                                        <MudText Class="overflow-hidden"
                                                 Style=@($"height: 1.6rem;font-size: clamp(10px, {8f / Math.Max(1, attack.Description.Length)}rem, 15px)")>@attack.Description</MudText>
                                    </MudItem>
                                }

                                <MudItem sm="3">
                                    <div class="d-flex gap-2">
                                        <MudDivider Vertical="true" FlexItem="true" />
                                        <MudText Class="overflow-hidden"
                                                 Style=@($"height: 1.6rem;font-size: clamp(10px, {7f / Math.Max(1, attack.StatusDescription.Length)}rem, 15px)")>@attack.StatusDescription</MudText>
                                    </div>
                                </MudItem>
                            }
                        </MudGrid>
                    </MudPaper>
                }
            </MudTabPanel>
            <MudTabPanel Text="フレーバーテキスト">
                <MudText Class="overflow-hidden" Typo="Typo.subtitle1">@monster.FlavorText</MudText>
            </MudTabPanel>
        </MudTabs>
    </MudContainer>
</MudPaper>

<FileUploader @ref=fileUpload />
<FileDownloader @ref=fileDownload />
<AudioPlayer @ref=audioPlayer />

@code {
    public BattleCard? My;
    public Dictionary<string, byte[]> MyImagesByName = [];

    public BattleCard? Enemy;
    public Dictionary<string, byte[]> EnemyImagesByName = [];

#pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
    FileUploader fileUpload;
    FileDownloader fileDownload;
    AudioPlayer audioPlayer;
#pragma warning restore CS8618

    class MonsterVM
    {
        public Monster Def { get; set; }
        public int CurrentHp { get; set; }
        public int DiffValue { get; set; }
        public BattleCardAttackVM[] Attacks { get; set; } = [];
        public BattleState? battleStateOrNull;
        public SpecialAttack? specialAttackOrNull;

        public bool IsAlive => CurrentHp > 0;

        public MarkupString FlavorText
            => (MarkupString)System.Web.HttpUtility.HtmlEncode(Def.FlavorText).Replace("\n", "<br />");

        public bool BattleStateAttached => battleStateOrNull != null;
        public string BattleStateName => battleStateOrNull?.Name ?? "なし";

        public bool SpecialAttackAttached => specialAttackOrNull != null;
        public string SpecialName => specialAttackOrNull?.Name ?? "なし";

        public MonsterVM(Monster source)
        {
            Def = source;
            CurrentHp = source.Hp;
            DiffValue = 0;
            Attacks = source.Attacks.Select(a => new BattleCardAttackVM(a)).ToArray();
        }

        public MonsterVM(Monster source, MonsterVM baseCard) : this(source)
        {
            // 現在の状態を引き継ぐ
            this.CurrentHp = Math.Min(this.Def.Hp, baseCard.CurrentHp);
            this.Buff(baseCard.DiffValue);
            if (baseCard.battleStateOrNull != null)
            {
                this.AttacheBattleState(baseCard.battleStateOrNull);
            }
        }

        public void AttacheBattleState(BattleState state)
        {
            battleStateOrNull = state;
            foreach (var (s, a) in state.Attacks.Zip(Attacks))
            {
                a.StatusDef = s;
            }
        }

        public void DettacheBattleState()
        {
            battleStateOrNull = null;
            foreach (var a in Attacks)
            {
                a.StatusDef = null;
            }
        }

        public void AttacheSpecial(SpecialAttack special)
        {
            this.specialAttackOrNull = special;
            foreach (var (s, a) in special.Attacks.Zip(Attacks))
            {
                a.Special = s;
            }
        }

        public void DettacheSpecial()
        {
            this.specialAttackOrNull = null;
            foreach (var a in Attacks)
            {
                a.Special = null;
            }
        }

        public void Reset()
        {
            CurrentHp = Def.Hp;
            DiffValue = 0;
            battleStateOrNull = null;
            foreach (var a in Attacks)
            {
                a.IsSelected = false;
                a.StatusDef = null;
            }
        }

        public int AddHp()
        {
            var heal = Math.Min(10, Def.Hp - CurrentHp);
            this.CurrentHp += heal;

            return heal;
        }

        public int SubHp()
        {
            var damage = Math.Min(this.CurrentHp, 10);
            this.CurrentHp -= damage;

            return damage;
        }

        public void Buff()
        {
            this.Buff(10);
        }

        public void Debuff()
        {
            this.Buff(-10);
        }

        public void Buff(int x)
        {
            this.DiffValue += x;
            foreach (var a in Attacks)
            {
                a.DiffValue += x;
            }
        }
    }

    class BattleCardAttackVM
    {
        public BattleCardAttack Def { get; set; }
        public BattleCardAttack? StatusDef { get; set; }
        public BattleCardAttack? Special { get; set; }
        public bool IsSelected { get; set; }
        public int DiffValue { get; set; }

        public BattleCardAttackVM(BattleCardAttack source)
        {
            Def = source;
            IsSelected = false;
        }

        public string Name => Def.Name;
        public BattleCardAttackType Type => this.Special == null ? Def.Type : this.Special.Type;

        public string Description => BuildDescription(this.Def, this.DiffValue);
        public string StatusDescription => this.StatusDef == null ? "" : BuildDescription(this.StatusDef, 0);
        public string SpecialName => Special?.Name ?? "";
        public string SpecialAttackDescription => this.Special == null ? "" : BuildDescription(this.Special, this.DiffValue);

        public static string BuildDescription(BattleCardAttack a, int diffValue)
        {
            var intValueWithBuff = Math.Max(0, a.IntValue + diffValue);

            return a.Type switch
            {
                BattleCardAttackType.Miss => "ミス",
                BattleCardAttackType.Attack => $"{a.Target.ToDisplayString()}に{intValueWithBuff}ダメージ",
                BattleCardAttackType.Heal => $"{a.Target.ToDisplayString()}を{intValueWithBuff}回復",
                BattleCardAttackType.ReAttack => $"もう一度・{a.Target.ToDisplayString()}に{intValueWithBuff}",
                BattleCardAttackType.Buff => $"{a.Target.ToDisplayString()}の攻撃を{a.IntValue:+#;-#;0}",
                BattleCardAttackType.BattleState => $"{a.Target.ToDisplayString()}を状態異常:{a.Value}",
                BattleCardAttackType.Special => $"必殺技:{a.Value}",
                BattleCardAttackType.Transform => $"{a.Value}に変身",
                _ => a.Value,
            };
        }
    }

    private BattleCard? battleCard = default;

    private MonsterVM monster = new MonsterVM(new()
        {
            Name = "",
            Hp = 0,
            FlavorText = "",
            ImageFileName = "",
            Attacks = [],
        }
    )
        {
            CurrentHp = 0
        };

    private bool cardLoaded => this.monster.Attacks.Any();
    private string actionName => this.monster.SpecialAttackAttached ? $"必殺: {this.monster.SpecialName}" : "たたかう";

    private readonly string cardImageElementId = Guid.NewGuid().ToString();

    public record TransformSelectItem(Monster Monster, BattleCard owner)
    {
        public string DisplayString => $"{Monster.Name}({owner.Main.Name})";
    }
    public record BattleStateSelectItem(BattleState BattleState, BattleCard owner)
    {
        public string DisplayString => $"{BattleState.Name}({owner.Main.Name})";
    }
    public record SpecialAttackSelectItem(SpecialAttack SpecialAttack, BattleCard owner)
    {
        public string DisplayString => $"{SpecialAttack.Name}({owner.Main.Name})";
    }

    private IReadOnlyList<TransformSelectItem> Transforms =>
        (this.My == null ? [] : new[] { new TransformSelectItem(this.My.Main, this.My) })
        .Concat(this.My?.Transforms?.Select(t => new TransformSelectItem(t, this.My))?.ToArray() ?? [])
        .Concat((this.Enemy == null ? [] : new[] { new TransformSelectItem(this.Enemy.Main, this.Enemy) }))
        .Concat(this.Enemy?.Transforms?.Select(t => new TransformSelectItem(t, this.Enemy))?.ToArray() ?? [])
        .ToArray();

    private IReadOnlyList<BattleStateSelectItem?> BattleStates => new[] { (BattleStateSelectItem?)null }
        .Concat(this.My?.BattleStates?.Select(t => new BattleStateSelectItem(t, this.My))?.ToArray() ?? [])
        .Concat(this.Enemy?.BattleStates?.Select(t => new BattleStateSelectItem(t, this.Enemy))?.ToArray() ?? [])
        .ToArray();

    private IReadOnlyList<SpecialAttackSelectItem?> Specials => new[] { (SpecialAttackSelectItem?)null }
        .Concat(this.My?.SpecialAttacks?.Select(t => new SpecialAttackSelectItem(t, this.My))?.ToArray() ?? [])
        .Concat(this.Enemy?.SpecialAttacks?.Select(t => new SpecialAttackSelectItem(t, this.Enemy))?.ToArray() ?? [])
        .ToArray();

    public async Task LoadMyCard(BattleCard card, Dictionary<string, byte[]> imagesByName)
    {
        this.My = card;
        this.MyImagesByName = imagesByName;

        this.monster = new MonsterVM(card.Main);
        var imageBytes = imagesByName.TryGetValue(monster.Def.ImageFileName, out var bytes) ? bytes : [];
        if (imageBytes.Length != 0)
        {
            await this.fileUpload.SetImage(cardImageElementId, new MemoryStream(imageBytes));
        }

        StateHasChanged();
    }

    public void LoadEnemyCard(BattleCard card, Dictionary<string, byte[]> imagesByName)
    {
        this.Enemy = card;
        this.EnemyImagesByName = imagesByName;
    }

    private async Task Transform(Monster transform)
    {
        this.monster = monster == null ? new(transform) : new(transform, this.monster);
        var imageBytes = this.MyImagesByName.TryGetValue(monster.Def.ImageFileName, out var bytes) ? bytes : [];
        if (imageBytes.Length != 0)
        {
            await this.fileUpload.SetImage(cardImageElementId, new MemoryStream(imageBytes));
        }
        imageBytes = this.EnemyImagesByName.TryGetValue(monster.Def.ImageFileName, out bytes) ? bytes : [];
        if (imageBytes.Length != 0)
        {
            await this.fileUpload.SetImage(cardImageElementId, new MemoryStream(imageBytes));
        }
    }

    private async Task ShowStateDialog()
    {
        var parameters = new DialogParameters<SimpleChoiceDialog<BattleStateSelectItem>>(){
            { x => x.ChoiceItems, BattleStates },
            { x => x.ItemToString, new Func<BattleStateSelectItem?, string>(x => x == null ? "なし" : x.DisplayString) }
        };

        var dialog = await DialogService.ShowAsync<SimpleChoiceDialog<BattleStateSelectItem>>("状態", parameters);
        var result = await dialog.Result;

        if (!(result?.Canceled ?? true))
        {
            var selectedValue = result.Data as BattleStateSelectItem;
            if (selectedValue == null)
            {
                this.monster.DettacheBattleState();
            }
            else
            {
                this.monster.AttacheBattleState(selectedValue.BattleState);
            }
        }
    }

    private async Task ShowSpecialDialog()
    {
        var parameters = new DialogParameters<SimpleChoiceDialog<SpecialAttackSelectItem>>(){
            { x => x.ChoiceItems, Specials },
            { x => x.ItemToString, new Func<SpecialAttackSelectItem, string>(x => x == null ? "なし" : x.DisplayString) }
        };

        var dialog = await DialogService.ShowAsync<SimpleChoiceDialog<SpecialAttackSelectItem>>("必殺", parameters);
        var result = await dialog.Result;

        if (!(result?.Canceled ?? true))
        {
            var selectedValue = result.Data as SpecialAttackSelectItem;
            if (selectedValue == null)
            {
                this.monster.DettacheSpecial();
            }
            else
            {
                this.monster.AttacheSpecial(selectedValue.SpecialAttack);
            }
        }
    }

    private async Task ShowTransformDialog()
    {
        var parameters = new DialogParameters<SimpleChoiceDialog<TransformSelectItem>>(){
            { x => x.ChoiceItems, Transforms },
            { x => x.ItemToString, new Func<TransformSelectItem, string>(x => x == null ? "なし" : x.DisplayString) }
        };

        var dialog = await DialogService.ShowAsync<SimpleChoiceDialog<TransformSelectItem>>("変身", parameters);
        var result = await dialog.Result;

        if (!(result?.Canceled ?? true))
        {
            var selectedValue = result.Data as TransformSelectItem;
            if (selectedValue != null)
            {
                await this.Transform(selectedValue.Monster);
            }
        }
    }

    private async Task AddHp()
    {
        var v = this.monster.AddHp();
        if (v > 0)
        {
            await this.audioPlayer.Play(AudioSrc.Heal);
        }
    }

    private async Task SubHp()
    {
        var v = this.monster.SubHp();
        if (v > 0)
        {
            if (this.monster.IsAlive)
            {
                await this.audioPlayer.Play(AudioSrc.Damage);
            }
            else
            {
                await this.audioPlayer.Play(AudioSrc.Death);
            }
        }
    }

    private async Task Buff()
    {
        this.monster.Buff();
        await this.audioPlayer.Play(AudioSrc.Buff);
    }

    private async Task Debuff()
    {
        this.monster.Debuff();
        await this.audioPlayer.Play(AudioSrc.Buff);
    }

    private async Task Attack()
    {
        foreach (var a in this.monster.Attacks)
        {
            a.IsSelected = false;
        }

        var attack = this.monster.Attacks[Random.Shared.Next(this.monster.Attacks.Length - 1)];

        foreach (var i in Enumerable.Range(0, 3))
        {
            foreach (var j in Enumerable.Range(0, this.monster.Attacks.Length))
            {
                if (j == 0)
                {
                    this.monster.Attacks[^1].IsSelected = false;
                }
                else
                {
                    this.monster.Attacks[j - 1].IsSelected = false;
                }
                this.monster.Attacks[j].IsSelected = true;

                StateHasChanged();
                await this.audioPlayer.Play(AudioSrc.ActionRoulette);
                await Task.Delay(TimeSpan.FromSeconds(0.1));
            }
        }

        this.monster.Attacks[^1].IsSelected = false;

        StateHasChanged();
        await Task.Delay(TimeSpan.FromSeconds(0.5));
        attack.IsSelected = true;
        await this.audioPlayer.Play(AudioSrc.Action);
    }
}
